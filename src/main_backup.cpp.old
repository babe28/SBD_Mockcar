#include <Arduino.h>
#include <esp32-hal.h>
#include <BluetoothSerial.h>
#include <Preferences.h>
#include <Wire.h>
#include <Time.h>
#include <SparkFun_VL6180X.h>

#define START_SENS 36         //START模擬ボタン
#define GOAL_SENS_1 39        //GOAL模擬ボタン
#define GOAL_SENS_2 34        //
#define GOAL_SENS_3 35        //

#define ADC_PIN 21              //ADコンバーターテスト
#define RESET_BUTTON_PIN 32     //reset button
#define SETUP_BUTTON_PIN 13     //setup button(longpress)
#define UP_BUTTON_PIN 14        //setup button up(A)
#define DOWN_BUTTON_PIN 12      //setup button down(B)
#define LONG_PRESS_THR 1500     //長押しスレッショルドタイム
#define RW_MODE false     //データ保存用
#define RO_MODE true      //データ保存用ReadOnly
#define MAX_HISTORY 5     //保存する履歴の最大数

#define LGFX_USE_V1
#include <LovyanGFX.hpp>

/*const float GAIN_1    = 1.01;  // Actual ALS Gain of 1.01
const float GAIN_1_25 = 1.28;  // Actual ALS Gain of 1.28
const float GAIN_1_67 = 1.72;  // Actual ALS Gain of 1.72
const float GAIN_2_5  = 2.6;   // Actual ALS Gain of 2.60
const float GAIN_5    = 5.21;  // Actual ALS Gain of 5.21
const float GAIN_10   = 10.32; // Actual ALS Gain of 10.32
const float GAIN_20   = 20;    // Actual ALS Gain of 20
const float GAIN_40   = 40;    // Actual ALS Gain of 40
*/
#define VL6180X_ADDRESS 0x29
//VL6180xIdentification identification;   //インスタンス作成
//VL6180x sensor(VL6180X_ADDRESS);        //センサー初期化


//レースタイマー構造体作成(過去タイム保存用)
struct racetimer {
  public:
  unsigned long history[MAX_HISTORY]; //過去のタイム
  unsigned long bestTime;             //ベストタイムはここ
};
racetimer timers[3];        //構造体を配列に

volatile unsigned long startTime = 0;             //スタートタイム記録用（差分の最初）
volatile unsigned long stopTimes[3] = {0,0,0};    //ストップタイム（ゴールタイム）記録用
volatile bool isTiming[3] = {false,false,false};  //ゴールしたかどうかの判定用
volatile bool resetFlag = false;                  //リセットボタン押されたかどうかの判定
volatile bool raceFlag = false;                   //レース中／計測中フラグ
volatile bool setupMode = false;                  //設定モードフラグ

bool firstrun = true;                   //起動一回目判定
int goalcount = 0;                      //ゴール台数カウント
int raceTotalCount = 0;                 //起動後何回レースしたか

unsigned long buttonPressStart = 0;   // ボタンが押された時刻を記録（長押し判定用）
bool isButtonPressed = false;         // ボタンが押されているか
bool inSetupMode = false;             // セットアップモードかどうか
unsigned long buttonPressStartA = 0;  // ボタンAの押下開始時間
unsigned long buttonPressStartB = 0;  // ボタンBの押下開始時間
bool isButtonPressedA = false;        // ボタンAが押されているか
bool isButtonPressedB = false;        // ボタンBが押されているか

int boardOPmode = 1;                  //ボード動作モード　0=NORMAL,1=LEGACY,2=OPTIONAL（当分レガシーモードのみ）

  //設定保存用（EEPROMの後継ライブラリPreferences）
  //まずは変数定義
  int on_cycle = 0; //起動回数
  float best_time_onboard = 0.0; //ボード最速タイム
  float sensor_gain_start = 1.00; //センサーのゲイン（スタート）
  float sensor_gain_goal = 1.00; //センサーゲイン（ゴール）

//割り込み設定ここから
void IRAM_ATTR startTimer() {
  startTime = millis();
  for (int i=0; i < 3; i++){
    isTiming[i] = true;
  }
    Serial.println("Timer started!");
    Serial.print("Start time: ");
    Serial.println(startTime);
}
void IRAM_ATTR stopTimer1() {
    if (isTiming[0]) {
        stopTimes[0] = millis();
        isTiming[0] = false;
    }
}
void IRAM_ATTR stopTimer2() {
    if (isTiming[1]) {
        stopTimes[1] = millis();
        isTiming[1] = false;
    }
}
void IRAM_ATTR stopTimer3() {
    if (isTiming[2]) {
        stopTimes[2] = millis();
        isTiming[2] = false;
    }
}
void IRAM_ATTR handleResetButton() {
    resetFlag = true; // Set the reset flag
}

/*
void printIdentification(struct VL6180xIdentification *temp)
{
  Serial.print("Model ID = ");
  Serial.println(temp->idModel);

  Serial.print("Model Rev = ");
  Serial.print(temp->idModelRevMajor);
  Serial.print(".");
  Serial.println(temp->idModelRevMinor);

  Serial.print("Module Rev = ");
  Serial.print(temp->idModuleRevMajor);
  Serial.print(".");
  Serial.println(temp->idModuleRevMinor);

  Serial.print("Manufacture Date = ");
  Serial.print((temp->idDate >> 3) & 0x001F);
  Serial.print("/");
  Serial.print((temp->idDate >> 8) & 0x000F);
  Serial.print("/1");
  Serial.print((temp->idDate >> 12) & 0x000F);
  Serial.print(" Phase: ");
  Serial.println(temp->idDate & 0x0007);

  Serial.print("Manufacture Time (s)= ");
  Serial.println(temp->idTime * 2);
  Serial.println();
  Serial.println();
}
*/

BluetoothSerial SerialBT;     //Bluetoothシリアルのインスタンス作成

class LGFX : public lgfx::LGFX_Device
{
public:
  lgfx::Panel_CVBS _panel_instance;
  LGFX(void)
  {
    { // 表示パネル制御の設定
      auto cfg = _panel_instance.config();    // 表示パネル設定用の構造体を取得します。
      // 出力解像度を設定;
      cfg.memory_width  = 240; // 出力解像度 幅
      cfg.memory_height = 160; // 出力解像度 高さ
      // 実際に利用する解像度を設定;
      cfg.panel_width  = 240;  // 実際に使用する幅   (memory_width と同値か小さい値を設定する)
      cfg.panel_height = 160;  // 実際に使用する高さ (memory_heightと同値か小さい値を設定する)
      // 表示位置オフセット量を設定;
      cfg.offset_x = 0;       // 表示位置を右にずらす量 (初期値 0)
      cfg.offset_y = 0;       // 表示位置を下にずらす量 (初期値 0)
      _panel_instance.config(cfg);

      // 通常は memory_width と panel_width に同じ値を指定し、 offset_x = 0 で使用します。;
      // 画面端の表示が画面外に隠れるのを防止したい場合は、 panel_width の値をmemory_widthより小さくし、offset_x で左右の位置調整をします。;
      // 例えば memory_width より panel_width を 32 小さい値に設定した場合、offset_x に 16 を設定することで左右位置が中央寄せになります。;
      // 上下方向 (memory_height , panel_height , offset_y ) についても同様に、必要に応じて調整してください。;
    }

    {
      auto cfg = _panel_instance.config_detail();

      // 出力信号の種類を設定;
      // cfg.signal_type = cfg.signal_type_t::NTSC;
      cfg.signal_type = cfg.signal_type_t::NTSC_J;

      // 出力先のGPIO番号を設定;
      cfg.pin_dac = 26;       // DACを使用するため、 25 または 26 のみが選択できます;
      // PSRAMメモリ割当の設定;
      cfg.use_psram = 1;      // 0=PSRAM不使用 / 1=PSRAMとSRAMを半々使用 / 2=全部PSRAM使用;
      // 出力信号の振幅の強さを設定;
      cfg.output_level = 128; // 初期値128
      // ※ GPIOに保護抵抗が付いている等の理由で信号が減衰する場合は数値を上げる。;
      // ※ M5StackCore2 はGPIOに保護抵抗が付いているため 200 を推奨。;
      // 彩度信号の振幅の強さを設定;
      cfg.chroma_level = 128; // 初期値128
      // 数値を下げると彩度が下がり、0で白黒になります。数値を上げると彩度が上がります。;

      // バックグラウンドでPSRAMの読出しを行うタスクの優先度を設定;
      // cfg.task_priority = 25;
      // バックグラウンドでPSRAMの読出しを行うタスクを実行するCPUを選択 (APP_CPU_NUM or PRO_CPU_NUM);
      // cfg.task_pinned_core = PRO_CPU_NUM;
      _panel_instance.config_detail(cfg);
    }
    setPanel(&_panel_instance);
  }
};

LGFX gfx; //インスタンス名gfx
static LGFX_Sprite sprite1(&gfx); //スプライト作成
static LGFX_Sprite sprite2(&gfx);
static LGFX_Sprite sprite3(&gfx);


//セットアップ関数ここから～～～～～～
void setup(void)
{
  Serial.begin(115200); // Start Serial at 115200bps
  Wire.begin();         // Start I2C library

  gfx.init();
  gfx.setFont(&fonts::FreeSans12pt7b);      //基本フォントの予定
  gfx.setTextWrap(false);                   //テキスト折り返し　しない
  gfx.setTextSize(0.8);                     //テキストサイズ0.7倍
  sprite1.createSprite(135,35);             //7セグLEDの部分のスプライト作成
  sprite2.createSprite(135,35);
  sprite3.createSprite(135,35);

  delay(10);
  gfx.setCursor(9,60);                  //画面センターに表示
  gfx.printf("MOCKCAR RACEv0.2");
  gfx.drawRect(20,120,200,10);          //プログレスバー外枠
  delay(200);                           // delay .1s
  Serial.print("initilize.");
  gfx.fillRect(20,120,20,10);           //プログレスバー10%
  delay(200);                           // delay .1s

 // sensor.getIdentification(&identification); // Retrieve manufacture info from device memory
 // printIdentification(&identification);      // Helper function to print all the Module information

//  if (sensor.VL6180xInit() != 0)
//  {
//    Serial.println("Failed to initialize. Freezing..."); // Initialize device and check for errors
//    while (1)
//      ;
//  }
//  sensor.VL6180xDefautSettings(); // Load default settings to get started.

  //入出力ピン設定
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);
  pinMode(UP_BUTTON_PIN, INPUT_PULLUP);
  pinMode(DOWN_BUTTON_PIN, INPUT_PULLUP);
  pinMode(SETUP_BUTTON_PIN,INPUT_PULLUP);
  pinMode(START_SENS,INPUT);//暫定処理そして残念ながらInput専用でプルアップなし
  pinMode(GOAL_SENS_1, INPUT);//暫定処理
  pinMode(GOAL_SENS_2, INPUT);//暫定処理
  pinMode(GOAL_SENS_3, INPUT);//暫定処理
  gfx.fillRect(20,120,60,10);           //プログレスバー30%
  delay(200);                           // delay .1s
  Serial.println("I/O complete");

  analogReadResolution(12);           //ADコンバーター12ビット
  attachInterrupt(digitalPinToInterrupt(RESET_BUTTON_PIN), handleResetButton,FALLING);  //RESETボタンの割り込み

  SerialBT.begin("ESP32Timer"); //この名前でBluetoothの一覧に出てくる
  Serial.println("Bluetooth Start!");

    // タイマーの初期化
  for (int i = 0; i < 3; i++) {
      for (int j = 0; j < MAX_HISTORY; j++) {
          timers[i].history[j] = 0;
      }
      timers[i].bestTime = 0;
   }
  gfx.fillRect(20,120,80,10);           //プログレスバー40%
  delay(200);                           // delay .1s

  //設定保存用（EEPROMの後継ライブラリPreferences）
  bool doesExist;
  String settings = "none";                   //ボード設定記録用（未使用）
  //ここから読み書きルーチン
  Preferences preferences;
  preferences.begin("my_settings",RW_MODE); 

  doesExist = preferences.isKey("my_settings");   //設定があるかどうか確認
  if(doesExist == false){
    /* 初期起動のときはここが実行される */
    preferences.putUInt("on_cycle", 1);//起動回数書き込み 9999回超えたらリセットしたほうがいいな
    preferences.putString("settings","none");
    Serial.println("First Load Initialize");
  }
  else {
    //２回目以降の起動のときはここ実行
    best_time_onboard = preferences.getFloat("besttime");
    on_cycle = preferences.getInt("on_cycle");
    Serial.println("Load Initialize");
    if(on_cycle > 9999){ //intの限界を超えないようにリセット
      preferences.putUInt("on_cycle",1);
    }
  }
  preferences.end();//preferences終了
  gfx.fillRect(20,120,150,10);           //プログレスバー80%
  delay(200);                           // delay .1s

  gfx.setTextSize(1);                       //テキストサイズ1倍
  SerialBT.println("setup finished.");
  Serial.println("setup finished");

  gfx.setColor(TFT_BLACK);
  gfx.fillRect(0,0,240,160);
  gfx.setCursor(5,5);
  gfx.setTextColor(TFT_YELLOW);
  gfx.printf("CYCLE=%d",on_cycle);

  gfx.fillRect(20,120,200,10);           //プログレスバー80%
  delay(3000);                           // delay
}
/***************************************************
 * setup関数ここまで
 ****************************************************/



void addTime(int timerId, unsigned long newTime) {
    racetimer &timer = timers[timerId];

    // 履歴をシフト（FIFO管理）
    for (int i = MAX_HISTORY - 1; i > 0; i--) {
        timer.history[i] = timer.history[i - 1];
    }
    timer.history[0] = newTime; // 新しいタイムを追加
    // 最速タイムを更新
    if (timer.bestTime == 0 || newTime < timer.bestTime) {
        timer.bestTime = newTime;
    }
}

//タイマーリセット関数
void resetTimers() {
    startTime = 0;
  for (int i = 0; i < 3; i++) {
        for (int j = 0; j < MAX_HISTORY; j++) {
            timers[i].history[j] = 0;
        }
        timers[i].bestTime = 0;
        isTiming[i] = false;
    }
    gfx.fillScreen(TFT_BLACK); // Clear display
    Serial.println("Timers reset!");
}

//タイマー表示関数
void displayTime(int timerId, unsigned long timeMillis) {
    unsigned long seconds = timeMillis / 1000;
    unsigned long milliseconds = timeMillis % 1000;

    // Set text properties
    gfx.setTextSize(0.8);
    gfx.setFont(&fonts::Font7);
    gfx.setTextColor(TFT_YELLOW,TFT_BLACK);

    // タイマーIDによって座標をずらす
    int y = 10 + (timerId - 1) * 42;

    // Clear previous display
    gfx.fillRect(0, y, 240, 30, TFT_BLACK);

    // Draw current time
    gfx.setCursor(10, y);
    gfx.printf("T %d: %02lu.%03lu", timerId, seconds, milliseconds);//２桁・３桁(luはunsigned long int)
}

//ディスプレイ初期化（起動時）
void displaySplash(){
  /* メモリから読み出した内容・バージョン情報
  その他、情報を出力、ロゴを出力  */
  gfx.setCursor(10,50);
  gfx.print("SPLASH");

  delay(1000);
  gfx.fillScreen(TFT_BLACK);
}

void memory_wirte(){
  Preferences preferences;
  preferences.begin("my_settings",RW_MODE); //２番目の引数が省略・・・読み書きモード
}


//ディスプレイ初期化（リセット後）
void displayinit(){
  /* 画面初期化 */
  gfx.fillScreen(TFT_BLACK);
  gfx.setColor(TFT_WHITE);
  gfx.drawFastHLine(5,40,200);
  gfx.drawFastHLine(5,80,200);
  gfx.drawFastHLine(5,80,200);
  gfx.setColor(TFT_SKYBLUE);
  gfx.fillRect(0,135,240,50);

  // Set text properties
    gfx.setTextSize(0.8);
    gfx.setTextColor(TFT_WHITE, TFT_BLACK);
    // タイマーIDによって座標をずらす

    // Draw current time
    gfx.setCursor(15, 10);
    gfx.setFont(&fonts::Font7);
    gfx.setColor(TFT_YELLOW);
    gfx.printf("1: 00.000");
    gfx.setCursor(10, 52);
    gfx.printf("1: 00.000");
    gfx.setCursor(10, 96);
    gfx.printf("1: 00.000");
}

void sensordetect(){
  // Get Ambient Light level and report in LUX
  Serial.print("Ambient Light Level (Lux) = ");

  // Input GAIN for light levels,
  //  GAIN_20     // Actual ALS Gain of 20
  //  GAIN_10     // Actual ALS Gain of 10.32
  //  GAIN_5      // Actual ALS Gain of 5.21
  //  GAIN_2_5    // Actual ALS Gain of 2.60
  //  GAIN_1_67   // Actual ALS Gain of 1.72
  //  GAIN_1_25   // Actual ALS Gain of 1.28
  //  GAIN_1      // Actual ALS Gain of 1.01
  //  GAIN_40     // Actual ALS Gain of 40

//  Serial.println(sensor.getAmbientLight(GAIN_1));

  // Get Distance and report in mm
//  Serial.print("Distance measured (mm) = ");
//  Serial.println(sensor.getDistance());


  int adcValue = analogRead(ADC_PIN);
  float voltage = (adcValue / 4095.0) * 3.3; //電圧に変換

}


//Bluetoothへ
void sendBluetoothData() {
    for (int i = 0; i < 3; i++) {
        if (!isTiming[i] && stopTimes[i] > 0) {
            unsigned long finalTime = stopTimes[i] - startTime;
            SerialBT.printf("Timer %d: %lu ms\n", i + 1, finalTime);
        }
    }
}

//センサー(スタート検知)
void startsensor(){
  int start_btn = digitalRead(START_SENS);
  int goal_btn1 = digitalRead(GOAL_SENS_1);
  int goal_btn2 = digitalRead(GOAL_SENS_2);
  int goal_btn3 = digitalRead(GOAL_SENS_3);


  if(start_btn == LOW){
    raceFlag = true;
    Serial.println("Race Flagment ON");
    startTimer();
    raceTotalCount++;
    delay(100);
  }

  if(goal_btn1 == LOW){
    Serial.println("TimerStop1");
    goalcount++;
    delay(100);
    stopTimer1();
  }
    if(goal_btn2 == LOW){
    Serial.println("TimerStop2");
    goalcount++;
    delay(100);
    stopTimer2();
  }
    if(goal_btn3 == LOW){
    raceFlag = false;
    Serial.println("TimerStop3");
    goalcount++;
    delay(100);
    stopTimer3();
  }

  if(goalcount > 2){
    raceFlag = false;
    Serial.println("Race Flagment False");
    goalcount = 0;
  }
}

//設定モードに入るための長押し検知
void detectLongPressForSetup() {
    int buttonState = digitalRead(SETUP_BUTTON_PIN);

    if (buttonState == LOW) { // ボタンが押されている
        if (!isButtonPressed) { // 初回押下検知
            buttonPressStart = millis();
            isButtonPressed = true;
        } else if (millis() - buttonPressStart > LONG_PRESS_THR && !inSetupMode) {
            // 長押しを検知
            inSetupMode = true;
            Serial.println("Long press detected! Entering setup mode...");
            gfx.setCursor(5,190);
            gfx.printf("Setup Mode");
        }
    } else { // ボタンが離された
        isButtonPressed = false;
    }
}

void detectExitSetupMode() {
    int buttonStateA = digitalRead(UP_BUTTON_PIN);
    int buttonStateB = digitalRead(DOWN_BUTTON_PIN);

    if (buttonStateA == LOW && buttonStateB == LOW) { // 両方のボタンが押されている
        if (!isButtonPressedA || !isButtonPressedB) { // 初回押下
            buttonPressStartA = millis();
            buttonPressStartB = millis();
            isButtonPressedA = true;
            isButtonPressedB = true;
        } else if (millis() - buttonPressStartA > LONG_PRESS_THR && millis() - buttonPressStartB > LONG_PRESS_THR) {
            inSetupMode = false;
            Serial.println("Exiting setup mode...");
            displayinit();                            //画面初期化
        }
    } else { // どちらかのボタンが離された
        isButtonPressedA = false;
        isButtonPressedB = false;
    }
}


/***************************************************************
 メイン関数　ループ　はここから
 *****************************************************************/
void loop(void)
{
  if(firstrun == true){ //起動時のみ
    displaySplash();
    displayinit();
    firstrun = false;
  }else{
    gfx.setCursor(3,135);
    gfx.setTextSize(0.5);
    gfx.setFont(&fonts::FreeSans12pt7b);
    gfx.setTextColor(TFT_WHITE,TFT_SKYBLUE);
    gfx.printf("RACE COUNT%d FASTEST:00.000",raceTotalCount);
  }

  //センサー監視
  startsensor();

  if(resetFlag) { //resetFlagは割り込みで入る
    resetTimers();
    resetFlag = false;

    sprite1.deleteSprite(); //リセット時にスプライト開放（メモリ解放）
    sprite2.deleteSprite();
    sprite3.deleteSprite();
    delay(200); //なんとなく少しディレイ
    displayinit();
  }
  //タイマー処理


  //描画処理 raceFlag=true のときに実行
  //startの際のmillisを記録、今のmillisとの差分として現在タイムを表示
  //もしstopTimesに記録が入れば、止める
  if(raceFlag){
      for (int i = 0; i < 3; i++) {
        if (isTiming[i]) {
            unsigned long elapsedTime = millis() - startTime;
            displayTime(i + 1, elapsedTime);
        } else if (stopTimes[i] > 0) {
            unsigned long finalTime = stopTimes[i] - startTime;
            displayTime(i + 1, finalTime);
        }
    }
  }else{
      delay(500);
  }

  //通信処理


    //セットアップ画面へ
    if (inSetupMode) {
      detectExitSetupMode();//セットアップモードを抜ける
        Serial.println("Setup mode entered!");
         // セットアップモードの処理
          /*実装したい処理
            センサーのゲイン調整・センサーのゲイン表示・センサー状態表示
         */
        gfx.fillScreen(TFT_BLACK);
        gfx.setCursor(5,5);
        gfx.setFont(&fonts::FreeSans12pt7b);
        gfx.setTextColor(TFT_WHITE); //white
        gfx.println("====== SETUP MODE ======");
        if(boardOPmode = 1){
          gfx.setTextColor(TFT_CYAN);
        gfx.println("LEGACY_MODE");
          gfx.setTextColor(TFT_WHITE);
        }
        gfx.printf("SENSOR GAIN(S):%f¥n",sensor_gain_start);
        gfx.printf("SENSOR GAIN(G):%f¥n",sensor_gain_goal);

        gfx.setCursor(10,120);
        gfx.printf("!press both UP/DOWN button to EXIT!");

        delay(500); // ここでセットアップモードの処理を実行（仮）   
    } else {
      detectLongPressForSetup();// 長押し検知処理
    }
}
//メイン関数ここまで（ループ）